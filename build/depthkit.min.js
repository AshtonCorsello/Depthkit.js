!function e(i,t,n){function o(r,s){if(!t[r]){if(!i[r]){var l="function"==typeof require&&require;if(!s&&l)return l(r,!0);if(a)return a(r,!0);var u=new Error("Cannot find module '"+r+"'");throw u.code="MODULE_NOT_FOUND",u}var h=t[r]={exports:{}};i[r][0].call(h.exports,function(e){var t=i[r][1][e];return o(t||e)},h,h.exports,e,i,t,n)}return t[r].exports}for(var a="function"==typeof require&&require,r=0;r<n.length;r++)o(n[r]);return o}({1:[function(e,i,t){i.exports=function(e){"string"==typeof e&&(e=[e]);for(var i=[].slice.call(arguments,1),t=[],n=0;n<e.length-1;n++)t.push(e[n],i[n]||"");return t.push(e[n]),t.join("")}},{}],2:[function(e,i,t){"use strict";function n(e,i){if(!(e instanceof i))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var o=function(){function e(e,i){for(var t=0;t<i.length;t++){var n=i[t];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(i,t,n){return t&&e(i.prototype,t),n&&e(i,n),i}}(),a=e("glslify"),r=function(){function e(){var i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"mesh",t=arguments[1],o=this,r=arguments[2];arguments[3];n(this,e);var s=a(["#define GLSLIFY 1\nuniform sampler2D map;\nuniform float opacity;\n\nuniform float uvdy;\nuniform float uvdx;\n\nvarying float visibility;\nvarying vec2 vUv;\nvarying vec3 vNormal;\nvarying vec3 vPos;\n\nvoid main() {\n\n    if ( visibility < 0.75 ) discard;\n\n    vec4 color = texture2D( map, vUv + vec2(uvdx, uvdy));\n    color.w = opacity;\n\n    gl_FragColor = color;\n    \n}"]),l=a(["#define GLSLIFY 1\nuniform float mindepth;\nuniform float maxdepth;\n\nuniform float width;\nuniform float height;\n\nuniform bool isPoints;\nuniform float pointSize;\n\nuniform float time;\n\nvarying vec3 vNormal;\nvarying vec3 vPos;\n\n//TODO: make uniforms\nconst float fx = 1.11087;\nconst float fy = 0.832305;\n\nuniform sampler2D map;\n\n//Making z global\nfloat z;\n\nvarying float visibility;\nvarying vec2 vUv;\n\nvec3 rgb2hsl( vec3 color ) {\n    float h = 0.0;\n    float s = 0.0;\n    float l = 0.0;\n    float r = color.r;\n    float g = color.g;\n    float b = color.b;\n    float cMin = min( r, min( g, b ) );\n    float cMax = max( r, max( g, b ) );\n    l =  ( cMax + cMin ) / 2.0;\n    if ( cMax > cMin ) {\n        float cDelta = cMax - cMin;\n        // saturation\n        if ( l < 0.5 ) {\n            s = cDelta / ( cMax + cMin );\n        } else {\n            s = cDelta / ( 2.0 - ( cMax + cMin ) );\n        }\n\n        // hue\n        if ( r == cMax ) {\n            h = ( g - b ) / cDelta;\n        } else if ( g == cMax ) {\n            h = 2.0 + ( b - r ) / cDelta;\n        } else {\n            h = 4.0 + ( r - g ) / cDelta;\n        }\n\n        if ( h < 0.0) {\n            h += 6.0;\n        }\n        h = h / 6.0;\n\n    }\n    return vec3( h, s, l );\n}\n\nvec3 xyz( float x, float y, float depth ) {\n    z = depth * ( maxdepth - mindepth ) + mindepth;\n    return vec3( ( x / height  ) * z * fx, ( y / (width * 2.0)  ) * z * fy, - z );\n}\n\nvoid main() {\n\n    vUv = vec2( ( position.x + 512.0 ) / 1024.0 , ( position.y + 512.0  ) / 1024.0 );\n\n    vUv.y = vUv.y * 0.5;// + 0.5;\n\n    vPos = (modelMatrix * vec4(position, 1.0 )).xyz;\n    vNormal = normalMatrix * normal;\n\n    vec3 hsl = rgb2hsl( texture2D( map, vUv ).xyz );\n    vec4 pos = vec4( xyz( position.x, position.y, hsl.x ), 1.0 );\n    pos.z += 2600.0;\n\n    visibility = hsl.z * 2.1;\n\n    if(isPoints){\n        gl_PointSize = pointSize;\n    }\n\n    gl_Position = projectionMatrix * modelViewMatrix * pos;\n}"]);switch(this.VERTS_WIDE=256,this.VERTS_TALL=256,this.video=document.createElement("video"),this.video.crossOrigin="anonymous",this.video.setAttribute("crossorigin","anonymous"),this.video.src=r,this.video.autoplay=!1,this.video.loop=!1,this.videoTexture=new THREE.VideoTexture(this.video),this.videoTexture.minFilter=THREE.NearestFilter,this.videoTexture.magFilter=THREE.LinearFilter,this.videoTexture.format=THREE.RGBFormat,this.videoTexture.generateMipmaps=!1,this.manager=new THREE.LoadingManager,this.props,this.geo=this.buildGeomtery(),this.material=new THREE.ShaderMaterial({uniforms:{map:{type:"t",value:this.videoTexture},time:{type:"f",value:0},mindepth:{type:"f",value:0},maxdepth:{type:"f",value:0},uvdy:{type:"f",value:.5},uvdx:{type:"f",value:0},width:{type:"f",value:0},height:{type:"f",value:0},opacity:{type:"f",value:1},isPoints:{type:"b",value:!1},pointSize:{type:"f",value:3}},vertexShader:l,fragmentShader:s,transparent:!0}),this.material.side=THREE.DoubleSide,i){case"wire":this.material.wireframe=!0,this.mesh=new THREE.Mesh(this.geo,this.material);break;case"points":this.material.uniforms.isPoints.value=!0,this.mesh=new THREE.Points(this.geo,this.material);break;default:this.mesh=new THREE.Mesh(this.geo,this.material)}this.jsonLoader=new THREE.FileLoader(this.manager),this.jsonLoader.setResponseType("json"),this.jsonLoader.load(t,function(e){o.props=e,o.material.uniforms.width.value=o.props.textureWidth,o.material.uniforms.height.value=o.props.textureHeight,o.material.uniforms.mindepth.value=o.props.nearClip,o.material.uniforms.maxdepth.value=o.props.farClip}),this.mesh.depthkit=this;var u=new THREE.SphereGeometry(300,32,32),h=new THREE.MeshBasicMaterial({color:16776960,wireframe:!0});return this.colider=new THREE.Mesh(u,h),this.colider.scale.set(5,2.5,2.5),this.colider.visible=!1,this.mesh.add(this.colider),this.mesh.name="depthkit",this.mesh}return o(e,[{key:"buildGeomtery",value:function(){for(var e=new THREE.Geometry,i=0;i<this.VERTS_TALL;i++)for(var t=0;t<this.VERTS_WIDE;t++)e.vertices.push(new THREE.Vector3(5*t-640,480-5*i,0));for(var n=0;n<this.VERTS_TALL-1;n++)for(var o=0;o<this.VERTS_WIDE-1;o++)e.faces.push(new THREE.Face3(o+n*this.VERTS_WIDE,o+(n+1)*this.VERTS_WIDE,o+1+n*this.VERTS_WIDE)),e.faces.push(new THREE.Face3(o+1+n*this.VERTS_WIDE,o+(n+1)*this.VERTS_WIDE,o+1+(n+1)*this.VERTS_WIDE));return e}},{key:"setPointSize",value:function(e){this.material.uniforms.isPoints.value?this.material.uniforms.pointSize.value=e:console.warn("Can not set point size because the current character is not set to render points")}},{key:"setOpacity",value:function(e){this.material.uniforms.opacity.value=e}},{key:"play",value:function(){this.video.isPlaying?console.warn("Can not play because the character is already playing"):this.video.play()}},{key:"stop",value:function(){this.video.currentTime=0,this.video.pause()}},{key:"pause",value:function(){this.video.pause()}},{key:"setLoop",value:function(e){this.video.loop=e}},{key:"setVolume",value:function(e){this.video.volume=e}},{key:"update",value:function(e){this.material.uniforms.time.value=e}},{key:"dispose",value:function(){}}]),e}();t.default=r},{glslify:1}],3:[function(e,i,t){"use strict";var n=function(e){return e&&e.__esModule?e:{default:e}}(e("./depthkit"));window.DepthKit=n.default},{"./depthkit":2}]},{},[3]);
